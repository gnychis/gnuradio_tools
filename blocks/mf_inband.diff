Index: usrp/host/lib/inband/symbols_usrp_low_level_cs.h
===================================================================
--- usrp/host/lib/inband/symbols_usrp_low_level_cs.h	(revision 8178)
+++ usrp/host/lib/inband/symbols_usrp_low_level_cs.h	(working copy)
@@ -43,5 +43,6 @@
 static pmt_t s_op_spi_read = pmt_intern("op-spi-read");
 static pmt_t s_op_spi_read_reply = pmt_intern("op-spi-read-reply");
 static pmt_t s_op_delay = pmt_intern("op-delay");
+static pmt_t s_op_mf_set = pmt_intern("s-op-mf-set");
 
 #endif /* INCLUDED_SYMBOLS_USRP_LOW_LEVEL_CS_H */
Index: usrp/host/lib/inband/usrp_inband_usb_packet.cc
===================================================================
--- usrp/host/lib/inband/usrp_inband_usb_packet.cc	(revision 8178)
+++ usrp/host/lib/inband/usrp_inband_usb_packet.cc	(working copy)
@@ -592,6 +592,53 @@
 }
 
 /*!
+ * \brief
+ *
+ * \returns true if the command was added to the packet, false otherwise.
+ */
+bool usrp_inband_usb_packet::cs_mf_set(long threshold, long ncoeff, int32_t *mf_data, size_t data_len)
+{
+  if(!align32())
+    return false;
+
+  int p_len = payload_len();
+
+  int mf_len = data_len + 2 + 4;   // 2 bytes between mbz and addr + 4 for threshold
+
+  int nco_div_6 = ncoeff / 6;
+  int nco_mod_6 = ncoeff % 6;
+  int nco_bits = (nco_div_6<<3) | nco_mod_6;
+  std::cout << "nco_div_6: " << nco_div_6 << "  nco_mod_6: " << nco_mod_6 << "  nco_bits: " << nco_bits << std::endl;
+
+  if((MAX_PAYLOAD - p_len) < (mf_len + CS_FIXED_LEN))
+    return false;
+
+  uint32_t word0 = 0;
+
+  word0 = (
+      ((OP_MF_SET & CS_OPCODE_MASK) << CS_OPCODE_SHIFT)
+    | ((mf_len & CS_LEN_MASK) << CS_LEN_SHIFT)
+    | ((nco_bits & CS_MFNCOEFF_MASK) << CS_MFNCOEFF_SHIFT)
+  );
+
+  uint32_t *payload = (uint32_t *) (d_payload + p_len);
+   *payload = host_to_usrp_u32(word0);
+   
+   payload += 1;
+   *payload = host_to_usrp_u32(threshold);
+
+   // Jump over the first word and write the data
+   // FIXME: Should the data be changed to usrp byte order?
+   payload += 1;
+   memcpy(payload, mf_data, data_len*4);
+
+  // Update payload length
+  incr_header_len(CS_FIXED_LEN + mf_len);
+
+  return true;
+}
+
+/*!
  * \brief Since all control packets contain subpackets which have the length of
  * the subpacket at a uniform location in the subpacket, this will return the
  * subpacket length given a byte offset of the start of the subpacket from the beginning of the packet.
@@ -783,7 +830,12 @@
 
       return pmt_list2(s_op_delay, ticks);
     }
-    
+
+    case OP_MF_SET:
+    {
+      return PMT_NIL;
+    }
+
     default:
       return PMT_NIL;
 
Index: usrp/host/lib/inband/usrp_rx.cc
===================================================================
--- usrp/host/lib/inband/usrp_rx.cc	(revision 8178)
+++ usrp/host/lib/inband/usrp_rx.cc	(working copy)
@@ -44,7 +44,7 @@
 
 usrp_rx::usrp_rx(mb_runtime *rt, const std::string &instance_name, pmt_t user_arg)
   : mb_mblock(rt, instance_name, user_arg),
-    d_disk_write(false),
+    d_disk_write(true),
     d_disk_write_pkt(false)   // if true, writes full packet, else just the payload
 {
   d_cs = define_port("cs", "usrp-rx-cs", true, mb_port::EXTERNAL);
Index: usrp/host/lib/inband/usrp_inband_usb_packet.h
===================================================================
--- usrp/host/lib/inband/usrp_inband_usb_packet.h	(revision 8178)
+++ usrp/host/lib/inband/usrp_inband_usb_packet.h	(working copy)
@@ -50,13 +50,14 @@
     OP_WRITE_REG_MASKED   = 0x03,
     OP_READ_REG           = 0x04,
     OP_READ_REG_REPLY     = 0x05,
-    OP_I2C_WRITE          = 0x06,
+    OP_MF_SET             = 0x06,
     OP_I2C_READ           = 0x07,
     OP_I2C_READ_REPLY     = 0x08,
     OP_SPI_WRITE          = 0x09,
     OP_SPI_READ           = 0x0a,
     OP_SPI_READ_REPLY     = 0x0b,
-    OP_DELAY              = 0x0c
+    OP_DELAY              = 0x0c,
+    OP_I2C_WRITE          = 0x0d
   };
 
   enum flags {
@@ -132,6 +133,9 @@
   static const int CS_SPINBYTES_MASK = 0xff;
   static const int CS_SPINBYTES_SHIFT = 24;
 
+  static const int CS_MFNCOEFF_MASK = 0xff;
+  static const int CS_MFNCOEFF_SHIFT = 0;
+
 public:
   
   void set_timestamp(uint32_t timestamp){
@@ -233,6 +237,7 @@
   bool cs_spi_write(long enables, long format, long opt_header_bytes, uint8_t *spi_data, long spi_data_len);
   bool cs_spi_read(long rid, long enables, long format, long opt_header_bytes, long n_bytes);
   bool cs_spi_read_reply(long rid, uint8_t *spi_data, long spi_data_len);
+  bool cs_mf_set(long threshold, long ncoeff, int32_t *mf_data, size_t data_len);
   int cs_len(int payload_offset);
   pmt_t read_subpacket(int payload_offset);
 };
Index: usrp/host/lib/inband/usrp_server.cc
===================================================================
--- usrp/host/lib/inband/usrp_server.cc	(revision 8178)
+++ usrp/host/lib/inband/usrp_server.cc	(working copy)
@@ -30,6 +30,7 @@
 #include <usrp_usb_interface.h>
 #include <fpga_regs_common.h>
 #include <fpga_regs_standard.h>
+#include <complex>
 
 #include <symbols_usrp_server_cs.h>
 #include <symbols_usrp_channel.h>
@@ -40,6 +41,7 @@
 static pmt_t s_shutdown = pmt_intern("%shutdown");
 
 typedef usrp_inband_usb_packet transport_pkt;   // makes conversion to gigabit easy
+typedef std::complex<float>     gr_complex;
 
 const static bool verbose = false;
 
@@ -1087,7 +1089,87 @@
       if(verbose)
         std::cout << "[USRP_SERVER] Received SPI read\n";
     }
+    
+    //--------- MF SET -----------//
+    // FIXME: could check that byte count does not exceed 2^8 which
+    // is the max length in the subpacket for # of bytes to read.
+    if(pmt_eq(subp_cmd, s_op_mf_set)) {
+      
+      long threshold = pmt_to_long(pmt_nth(0, subp_data));
+      pmt_t data = pmt_nth(1, subp_data);
 
+      // From pmt_any to gr_complex vector
+      std::vector<gr_complex> coeffs = boost::any_cast<std::vector<gr_complex> > (pmt_any_ref(data));
+
+      // Reverse the coefficients
+      std::reverse(coeffs.begin(), coeffs.end());
+
+      // New data to store the 2-bit coefficient version
+      size_t data_len;
+      pmt_t v_mf_data = pmt_make_u32vector((96*2)/32, 0);
+      int32_t *mf_data = (int32_t *) pmt_u32vector_writeable_elements(v_mf_data, data_len);
+
+      long ncoeff = coeffs.size();
+
+      // Convert from full coefficient set to 2-bit rotated version
+      int32_t *curr_word = mf_data;
+      for(int i=0; i < ncoeff; i++) {
+
+        curr_word = mf_data + i%6;
+
+        float real = coeffs[i].real();
+        float imag = -coeffs[i].imag(); // Need to take the complex conjugate
+
+        int opt_real, opt_imag;
+
+        if(real>0 && imag>=0) {         // Shift Q1 to (0,1) = 1 = 0b01
+          opt_real = 0;
+          opt_imag = 1;
+        }
+        else if(real<=0 && imag>0) {    // Shift Q2 to (-1,0) = 3 = 0b11
+          opt_real = 1;
+          opt_imag = 1;
+        }
+        else if(real<0 && imag<=0) {    // Shift Q3 to (0,-1) = 2 = 0b10
+          opt_real = 1;
+          opt_imag = 0;
+        }
+        else if(real>=0 && imag<0) {    // Shift Q4 to (1,0) = 0 = 0b00
+          opt_real = 0;
+          opt_imag = 0;
+        }
+
+        // This is done for reducing complexity in the FPGA
+        int real_shift = 32-(16-(i/6));
+        int imag_shift = 16-(16-(i/6));
+
+        std::cout << "  optreal: " << opt_real
+                  << "  optimag: " << opt_imag
+                  << std::endl;
+
+        *curr_word |= opt_real << real_shift;
+        *curr_word |= opt_imag << imag_shift;
+        
+      }
+
+
+      // Make the USB packet
+      if(!pkt->cs_mf_set(threshold, ncoeff, mf_data, data_len))
+      {
+        d_cs_usrp->send(s_cmd_usrp_write, 
+                        pmt_list3(invocation_handle, 
+                                  pmt_from_long(channel), 
+                                  v_packet));
+        
+        goto new_packet;
+      }
+      
+      if(verbose)
+        std::cout << "[USRP_SERVER] Received matched filter set\n"
+                  << "  ncoeffs: " << ncoeff
+                  << std::endl;
+    }
+
   subpkt_bail:
     curr_subpkt++;
 
Index: usrp/host/lib/inband/usrp_usb_interface.cc
===================================================================
--- usrp/host/lib/inband/usrp_usb_interface.cc	(revision 8178)
+++ usrp/host/lib/inband/usrp_usb_interface.cc	(working copy)
@@ -362,12 +362,14 @@
 
   if (verbose)
     std::cout << "[USRP_USB_INTERFACE] Setup RX channel\n";
+
+  d_urx->start();
     
-//  d_utx->_write_fpga_reg(FR_DEBUG_EN,0xf);
-//  d_utx->_write_oe(0, 0xffff, 0xffff);
-//  d_urx->_write_oe(0, 0xffff, 0xffff);
-//  d_utx->_write_oe(1, 0xffff, 0xffff);
-//  d_urx->_write_oe(1, 0xffff, 0xffff);
+  d_utx->_write_fpga_reg(FR_DEBUG_EN,0xf);
+  d_utx->_write_oe(0, 0xffff, 0xffff);
+  d_urx->_write_oe(0, 0xffff, 0xffff);
+  d_utx->_write_oe(1, 0xffff, 0xffff);
+  d_urx->_write_oe(1, 0xffff, 0xffff);
 
   d_cs->send(s_response_usrp_open, pmt_list2(invocation_handle, PMT_T));
 }
Index: usrp/host/apps-inband/test_usrp_inband_tx.cc
===================================================================
--- usrp/host/apps-inband/test_usrp_inband_tx.cc	(revision 8178)
+++ usrp/host/apps-inband/test_usrp_inband_tx.cc	(working copy)
@@ -37,6 +37,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <iostream>
+#include <fstream>
 
 #include <ui_nco.h>
 #include <symbols_usrp_server_cs.h>
@@ -119,7 +120,7 @@
   // Specify the RBF to use
   pmt_dict_set(usrp_dict,
                pmt_intern("rbf"),
-               pmt_intern("inband_1rxhb_1tx.rbf"));
+               pmt_intern("mftest23.rbf"));
 
   // Set TX and RX interpolations
   pmt_dict_set(usrp_dict,
@@ -302,7 +303,42 @@
   
   if(verbose)
     std::cout << "[TEST_USRP_INBAND_TX] Transmitting...\n";
-  
+
+  ///////////////////////////
+  std::vector<gr_complex> complex_coeffs;
+  std::string line;
+  std::ifstream coeffs("coeffs");
+  if(coeffs.is_open()) {
+    while(!coeffs.eof()) {
+      getline(coeffs,line);
+      if(line=="") break;
+      std::istringstream in(line);
+      std::vector<std::string> tokens;
+      for(std::string each; std::getline(in,each,' '); tokens.push_back(each));
+      std::istringstream sreal(tokens[0]), simag(tokens[1]);
+      float real, imag;
+      sreal >> real;
+      simag >> imag;
+      complex_coeffs.push_back(gr_complex(real, imag));
+    }
+    coeffs.close();
+  } else {
+    std::cout << "coeffs missing\n";
+    shutdown_all(PMT_NIL);
+  }
+
+  pmt_t v_coeff_data = pmt_make_any(complex_coeffs);
+
+  d_tx->send(s_cmd_to_control_channel,
+             pmt_list2(PMT_NIL,
+                       pmt_list1(
+                          pmt_list2(s_op_mf_set,
+                                    pmt_list2(pmt_from_long(50),
+                                              v_coeff_data)))));
+  std::cout << "coeffs sent from app\n";
+  fflush(stdout);
+  ////////////////////////////
+
   build_and_send_next_frame();	// fire off 4 to start pipeline
   build_and_send_next_frame();
   build_and_send_next_frame();
Index: usrp/host/apps-inband/test_usrp_inband_registers.cc
===================================================================
--- usrp/host/apps-inband/test_usrp_inband_registers.cc	(revision 8178)
+++ usrp/host/apps-inband/test_usrp_inband_registers.cc	(working copy)
@@ -119,7 +119,7 @@
   // Specify the RBF to use
   pmt_dict_set(usrp_dict,
                pmt_intern("rbf"),
-               pmt_intern("inband_1rxhb_1tx.rbf"));
+               pmt_intern("mftest9.rbf"));
 
   // Set TX and RX interpolations
   pmt_dict_set(usrp_dict,
@@ -373,7 +373,7 @@
 {
   d_state = WRITE_REGISTER;
 
-  long reg = 0;
+  long reg = 9;
 
   d_tx->send(s_cmd_to_control_channel,    // C/S packet
              pmt_list2(PMT_NIL,           // invoc handle
